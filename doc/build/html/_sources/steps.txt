Available steps
===============

A detailed description of all availble steps follows.

Source steps
------------


.. index:: fastq_source

FASTQ_source
~~~~~~~~~~~~

The FastqSource class acts as a source for FASTQ files. This source creates a
run for every sample.

Specify a file name pattern in *pattern* and define how sample names should
be determined from file names by specifyign a regular expression in *group*.

Sample index barcodes may specified by providing a filename to a CSV file
containing the columns *Sample_ID* and *Index* or directly by defining a
dictionary which maps indices to sample names.

**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      fastq_source [style=filled, fillcolor="#fce94f"];
      out_0 [label="first_read"];
      fastq_source -> out_0;
      out_1 [label="second_read"];
      fastq_source -> out_1;
   }    

**Options:**
  - **first_read** (str, required) -- Part of the file name that marks all files containing sequencing data of the first read. Example: 'R1.fastq' or '_1.fastq'
    
  - **group** (str, optional) -- A regular expression which is applied to found files, and which is used to determine the sample name from the file name. For example, ``(Sample_\d+)_R[12].fastq.gz``, when applied to a file called ``Sample_1_R1.fastq.gz``, would result in a sample name of ``Sample_1``. You can specify multiple capture groups in the regular expression.
    
  - **indices** (str/dict, optional) -- path to a CSV file or a dictionary of sample_id: barcode entries.
    
  - **paired_end** (bool, required) -- Specify whether the samples are paired end or not.
    
  - **pattern** (str, optional) -- A file name pattern, for example ``/home/test/fastq/Sample_*.fastq.gz``.
    
  - **sample_id_prefix** (str, optional) -- This optional prefix is prepended to every sample name.
    
  - **sample_to_files_map** (dict/str, optional) -- A listing of sample names and their associated files. This must be provided as a YAML dictionary.
    
  - **second_read** (str, required) -- Part of the file name that marks all files containing sequencing data of the second read. Example: 'R2.fastq' or '_2.fastq'
    

This step provides input files which already exists and therefore creates no tasks in the pipeline.

.. index:: raw_file_source

raw_file_source
~~~~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      raw_file_source [style=filled, fillcolor="#fce94f"];
      out_0 [label="raw"];
      raw_file_source -> out_0;
   }    

**Options:**
  - **group** (str, optional) -- A regular expression which is applied to found files, and which is used to determine the sample name from the file name. For example, `(Sample_\d+)_R[12].fastq.gz``, when applied to a file called ``Sample_1_R1.fastq.gz``, would result in a sample name of ``Sample_1``. You can specify multiple capture groups in the regular expression.
    
  - **pattern** (str, optional) -- A file name pattern, for example ``/home/test/fastq/Sample_*.fastq.gz``.
    
  - **sample_id_prefix** (str, optional)
    
  - **sample_to_files_map** (dict/str, optional) -- A listing of sample names and their associated files. This must be provided as a YAML dictionary.
    

This step provides input files which already exists and therefore creates no tasks in the pipeline.

.. index:: raw_file_sources

raw_file_sources
~~~~~~~~~~~~~~~~



The RawFileSources class acts as a tyemporary fix to get files into the pipeline.
This source creates a    run for every sample.

Specify a file name pattern in *pattern* and define how sample names should be
determined from file names by specifyign a regular expression in *group*.



**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      raw_file_sources [style=filled, fillcolor="#fce94f"];
      out_0 [label="raws"];
      raw_file_sources -> out_0;
   }    

**Options:**
  - **group** (str, required) -- A regular expression which is applied to found files, and which is used to determine the sample name from the file name. For example, ``(Sample_\d+)_R[12].fastq.gz``, when applied to a file called ``Sample_1_R1.fastq.gz``, would result in a sample name of ``Sample_1``. You can specify multiple capture groups in the regular expression.
    
  - **paired_end** (bool, required) -- Specify whether the samples are paired end or not.
    
  - **pattern** (str, required) -- A file name pattern, for example ``/home/test/fastq/Sample_*.fastq.gz``.
    
  - **sample_id_prefix** (str, optional) -- This optional prefix is prepended to every sample name.
    

This step provides input files which already exists and therefore creates no tasks in the pipeline.

.. index:: raw_url_source

raw_url_source
~~~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      raw_url_source [style=filled, fillcolor="#fce94f"];
      out_0 [label="raw"];
      raw_url_source -> out_0;
   }    

**Options:**
  - **sha1** (str, optional) -- expected SHA1 checksum of downloaded file
    
  - **url** (str, required) -- file URL
    

**Required tools:** curl, sha1sum

**CPU Cores:** 1

.. index:: run_folder_source

run_folder_source
~~~~~~~~~~~~~~~~~



This source looks for fastq.gz files in
``[path]/Unaligned/Project_*/Sample_*`` and pulls additional information
from CSV sample sheets it finds. It also makes sure that index information
for all samples is coherent and unambiguous.

**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      run_folder_source [style=filled, fillcolor="#fce94f"];
      out_0 [label="first_read"];
      run_folder_source -> out_0;
      out_1 [label="second_read"];
      run_folder_source -> out_1;
   }    

**Options:**
  - **first_read** (str, required) -- Part of the file name that marks all files containing sequencing data of the first read. Example: '_R1.fastq' or '_1.fastq'
    
  - **paired_end** (bool, required)
    
  - **path** (str, required)
    
  - **second_read** (str, required) -- Part of the file name that marks all files containing sequencing data of the second read. Example: 'R2.fastq' or '_2.fastq'
    

This step provides input files which already exists and therefore creates no tasks in the pipeline.

Processing steps
----------------

.. index:: bam_to_bed

bam_to_bed
~~~~~~~~~~



This step converts BAM files into BED files. It executes different command line
pipelines for single-end and paired-end data.

Single-end read data is converted via::

cat4m <bam-file> | bedtools bamtobed -i stdin | sort -k1,1 -k2,2n > <bed-file>

Paired-end read data is converted via::

cat4m <bam-file> | samtools view -bf 0x2 - | bedtools bamtobed -i stdin |
mate_pair_strand_switch | sort -k1,1 -k2,2n > <bed-file>


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      bam_to_bed [style=filled, fillcolor="#fce94f"];
      in_0 [label="alignments"];
      in_0 -> bam_to_bed;
      out_1 [label="alignments"];
      bam_to_bed -> out_1;
   }    

**Options:**
  - **tmp_dir** (str, required)
    

**Required tools:** bedtools, cat4m, mate_pair_strand_switch, samtools, sort

**CPU Cores:** 4

.. index:: bam_to_bed12

bam_to_bed12
~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      bam_to_bed12 [style=filled, fillcolor="#fce94f"];
      in_0 [label="alignments"];
      in_0 -> bam_to_bed12;
      out_1 [label="alignments"];
      bam_to_bed12 -> out_1;
   }    

**Options:**

**Required tools:** bedtools, cat4m, mate_pair_strand_switch, samtools, sort

**CPU Cores:** 4

.. index:: bam_to_sam

bam_to_sam
~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      bam_to_sam [style=filled, fillcolor="#fce94f"];
      in_0 [label="alignments"];
      in_0 -> bam_to_sam;
      out_1 [label="alignments"];
      bam_to_sam -> out_1;
   }    

**Options:**
  - **genome** (str, required)
    

**Required tools:** cat4m, pigz, samtools

**CPU Cores:** 4

.. index:: bed_to_bedgraph

bed_to_bedgraph
~~~~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      bed_to_bedgraph [style=filled, fillcolor="#fce94f"];
      in_0 [label="alignments"];
      in_0 -> bed_to_bedgraph;
      out_1 [label="tracks"];
      bed_to_bedgraph -> out_1;
   }    

**Options:**
  - **genome** (str, required)
    
  - **strand-specific** (bool, required)
    

**Required tools:** bedtools, cat4m

**CPU Cores:** 4

.. index:: bedgraph_to_bigwig

bedgraph_to_bigwig
~~~~~~~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      bedgraph_to_bigwig [style=filled, fillcolor="#fce94f"];
      in_0 [label="tracks"];
      in_0 -> bedgraph_to_bigwig;
      out_1 [label="tracks"];
      bedgraph_to_bigwig -> out_1;
   }    

**Options:**
  - **genome** (str, required)
    

**Required tools:** bedGraphToBigWig

**CPU Cores:** 4

.. index:: combine_assemblies

combine_assemblies
~~~~~~~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      combine_assemblies [style=filled, fillcolor="#fce94f"];
      in_0 [label="features_segemehl"];
      in_0 -> combine_assemblies;
      in_1 [label="features_tophat"];
      in_1 -> combine_assemblies;
      out_2 [label="features"];
      combine_assemblies -> out_2;
      out_3 [label="log_stderr"];
      combine_assemblies -> out_3;
      out_4 [label="log_stdout"];
      combine_assemblies -> out_4;
   }    

**Options:**
  - **mode** (str, required)
    
    - possible values:
    
      - no_transcript_overlap
  - **path_rscript** (str, required)
    
  - **run_id** (str, required)
    

**Required tools:** Rscript

**CPU Cores:** 1

.. index:: count_mapped_reads

count_mapped_reads
~~~~~~~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      count_mapped_reads [style=filled, fillcolor="#fce94f"];
      in_0 [label="alignments"];
      in_0 -> count_mapped_reads;
      out_1 [label="alignment-counts"];
      count_mapped_reads -> out_1;
   }    

**Options:**
  - **exclude_MAPQ_smaller_than** (int, required)
    
  - **set_FLAG_bits** (list, required)
    
  - **unset_FLAG_bits** (list, required)
    

**Required tools:** cat4m, pigz, samtools

**CPU Cores:** 4

.. index:: count_raw_reads

count_raw_reads
~~~~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      count_raw_reads [style=filled, fillcolor="#fce94f"];
      in_0 [label="reads"];
      in_0 -> count_raw_reads;
      out_1 [label="statistics"];
      count_raw_reads -> out_1;
   }    

**Options:**

**Required tools:** cat, pigz, wc

**CPU Cores:** 4

.. index:: count_raw_reads_crashing

count_raw_reads_crashing
~~~~~~~~~~~~~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      count_raw_reads_crashing [style=filled, fillcolor="#fce94f"];
      in_0 [label="reads"];
      in_0 -> count_raw_reads_crashing;
      out_1 [label="statistics"];
      count_raw_reads_crashing -> out_1;
   }    

**Options:**

**Required tools:** echo, pigz, wc

**CPU Cores:** 4

.. index:: cufflinks

cufflinks
~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      cufflinks [style=filled, fillcolor="#fce94f"];
      in_0 [label="alignments"];
      in_0 -> cufflinks;
      out_1 [label="features"];
      cufflinks -> out_1;
      out_2 [label="genes-fpkm"];
      cufflinks -> out_2;
      out_3 [label="isoforms_fpkm"];
      cufflinks -> out_3;
      out_4 [label="log_stderr"];
      cufflinks -> out_4;
      out_5 [label="skipped"];
      cufflinks -> out_5;
   }    

**Options:**
  - **library_type** (str, required)
    
  - **use_mask** (str, optional)
    

**Required tools:** cat4m, cufflinks, pigz

**CPU Cores:** 6

.. index:: cuffmerge

cuffmerge
~~~~~~~~~



Cuffmerge is included in the cufflinks package.
http://cufflinks.cbcb.umd.edu/manual.html

**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      cuffmerge [style=filled, fillcolor="#fce94f"];
      in_0 [label="features"];
      in_0 -> cuffmerge;
      out_1 [label="assemblies_txt"];
      cuffmerge -> out_1;
      out_2 [label="features"];
      cuffmerge -> out_2;
      out_3 [label="log_stderr"];
      cuffmerge -> out_3;
      out_4 [label="run_log"];
      cuffmerge -> out_4;
   }    

**Options:**
  - **genome** (str, required)
    
  - **reference** (str, required)
    
  - **run_id** (str, required)
    

**Required tools:** cat4m, cuffmerge, pigz

**CPU Cores:** 6

.. index:: cutadapt

cutadapt
~~~~~~~~



The cutadapt step can be used to clip adapter sequences from RNASeq reads.

Any adapter may contain ``((INDEX))`` which will be replaced with every
sample's index. The resulting adapter is checked for sanity and an
exception is thrown if the adapter looks non-legit.

**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      cutadapt [style=filled, fillcolor="#fce94f"];
      in_0 [label="first_read"];
      in_0 -> cutadapt;
      in_1 [label="second_read"];
      in_1 -> cutadapt;
      out_2 [label="first_read"];
      cutadapt -> out_2;
      out_3 [label="log_first_read"];
      cutadapt -> out_3;
      out_4 [label="log_second_read"];
      cutadapt -> out_4;
      out_5 [label="second_read"];
      cutadapt -> out_5;
   }    

**Options:**
  - **adapter-R1** (str, optional)
    
  - **adapter-R2** (str, optional)
    
  - **adapter-file** (str, optional)
    
  - **adapter-type** (str, optional)
    
  - **fix_qnames** (bool, required)
    
  - **minimal-length** (int, optional)
    
  - **use_reverse_complement** (bool, required)
    

**Required tools:** cat4m, cutadapt, fix_qnames, pigz

**CPU Cores:** 3

.. index:: fastqc

fastqc
~~~~~~



| The fastqc step  is a wrapper for the fastqc tool.
| It generates some quality metrics for fastq files.
| http://www.bioinformatics.babraham.ac.uk/projects/fastqc/
| For this specific instance only the zip archive is preserved

**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      fastqc [style=filled, fillcolor="#fce94f"];
      in_0 [label="first_read"];
      in_0 -> fastqc;
      in_1 [label="second_read"];
      in_1 -> fastqc;
      out_2 [label="first_read_fastqc_report"];
      fastqc -> out_2;
      out_3 [label="first_read_log_stderr"];
      fastqc -> out_3;
      out_4 [label="second_read_fastqc_report"];
      fastqc -> out_4;
      out_5 [label="second_read_log_stderr"];
      fastqc -> out_5;
   }    

**Options:**
  - **contaminent-file** (str, optional)
    

**Required tools:** fastqc

**CPU Cores:** 1

.. index:: fastqc_decorator_test

fastqc_decorator_test
~~~~~~~~~~~~~~~~~~~~~



| The fastqc step  is a wrapper for the fastqc tool.
| It generates some quality metrics for fastq files.
| http://www.bioinformatics.babraham.ac.uk/projects/fastqc/
| For this specific instance only the zip archive is preserved

**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      fastqc_decorator_test [style=filled, fillcolor="#fce94f"];
      in_0 [label="first_read"];
      in_0 -> fastqc_decorator_test;
      in_1 [label="second_read"];
      in_1 -> fastqc_decorator_test;
      out_2 [label="first_read_fastqc_report"];
      fastqc_decorator_test -> out_2;
      out_3 [label="first_read_log_stderr"];
      fastqc_decorator_test -> out_3;
      out_4 [label="second_read_fastqc_report"];
      fastqc_decorator_test -> out_4;
      out_5 [label="second_read_log_stderr"];
      fastqc_decorator_test -> out_5;
   }    

**Options:**
  - **contaminent-file** (str, optional)
    

**Required tools:** fastqc

**CPU Cores:** 1

.. index:: fix_cutadapt

fix_cutadapt
~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      fix_cutadapt [style=filled, fillcolor="#fce94f"];
      in_0 [label="first_read"];
      in_0 -> fix_cutadapt;
      in_1 [label="second_read"];
      in_1 -> fix_cutadapt;
      out_2 [label="first_read"];
      fix_cutadapt -> out_2;
      out_3 [label="second_read"];
      fix_cutadapt -> out_3;
   }    

**Options:**

**Required tools:** cat4m, fix_cutadapt, pigz

**CPU Cores:** 6

.. index:: fix_s2c

fix_s2c
~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      fix_s2c [style=filled, fillcolor="#fce94f"];
      in_0 [label="alignments"];
      in_0 -> fix_s2c;
      out_1 [label="alignments"];
      fix_s2c -> out_1;
   }    

**Options:**

**Required tools:** cat4m, fix_s2c, pigz, samtools

**CPU Cores:** 6

.. index:: grep

grep
~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      grep [style=filled, fillcolor="#fce94f"];
      in_0 [label="*"];
      in_0 -> grep;
      out_1 [label="*"];
      grep -> out_1;
   }    

**Options:**
  - **pattern** (str, required)
    

**Required tools:** cat4m, grep, pigz

**CPU Cores:** 4

.. index:: head

head
~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      head [style=filled, fillcolor="#fce94f"];
      in_0 [label="*"];
      in_0 -> head;
      out_1 [label="*"];
      head -> out_1;
   }    

**Options:**
  - **lines** (int, required)
    

**Required tools:** cat4m, head, pigz

**CPU Cores:** 4

.. index:: htseq_count

htseq_count
~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      htseq_count [style=filled, fillcolor="#fce94f"];
      in_0 [label="alignments"];
      in_0 -> htseq_count;
      in_1 [label="features"];
      in_1 -> htseq_count;
      out_2 [label="counts"];
      htseq_count -> out_2;
   }    

**Options:**
  - **idattr** (str, required)
    
  - **mode** (str, required)
    
  - **stranded** (str, required)
    
  - **type** (str, required)
    

**Required tools:** cat4m, grep, htseq-count, pigz, samtools

**CPU Cores:** 2

.. index:: macs14

macs14
~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      macs14 [style=filled, fillcolor="#fce94f"];
      in_0 [label="alignments"];
      in_0 -> macs14;
      out_1 [label="diagnosis"];
      macs14 -> out_1;
      out_2 [label="log"];
      macs14 -> out_2;
      out_3 [label="model"];
      macs14 -> out_3;
      out_4 [label="negative-peaks"];
      macs14 -> out_4;
      out_5 [label="peaks"];
      macs14 -> out_5;
      out_6 [label="summits"];
      macs14 -> out_6;
   }    

**Options:**
  - **control** (list, required)
    
  - **format** (str, required)
    
    - possible values:
    
      - BAM
      - BOWTIE
      - ELAND
      - ELANDEXPORT
      - ELANDMULTI
      - ELANDMULTIPET
      - SAM
  - **genome_size** (str, required)
    

**Required tools:** cat4m, macs14, pigz

**CPU Cores:** 4

.. index:: macs2

macs2
~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      macs2 [style=filled, fillcolor="#fce94f"];
      in_0 [label="alignments"];
      in_0 -> macs2;
      out_1 [label="diagnosis"];
      macs2 -> out_1;
      out_2 [label="gapped-peaks"];
      macs2 -> out_2;
      out_3 [label="log"];
      macs2 -> out_3;
      out_4 [label="model"];
      macs2 -> out_4;
      out_5 [label="peaks"];
      macs2 -> out_5;
      out_6 [label="peaks-xls"];
      macs2 -> out_6;
      out_7 [label="summits"];
      macs2 -> out_7;
   }    

**Options:**
  - **broad** (bool, optional)
    
  - **broad-cutoff** (float, optional)
    
  - **call-summits** (bool, optional)
    
  - **control** (dict, required)
    
  - **down-sample** (bool, optional)
    
  - **format** (str, required)
    
    - possible values:
    
      - BAM
      - BAMPE
      - BED
      - BOWTIE
      - ELAND
      - ELANDEXPORT
      - ELANDMULTI
      - ELANDMULTIPET
      - SAM
  - **genome_size** (str, required)
    
  - **keep-duplicates** (bool, optional)
    
  - **large-local** (str, optional)
    
  - **pvalue-cutoff** (float, optional)
    
  - **qvalue-cutoff** (float, optional)
    
  - **read-length** (int, optional)
    
  - **shift** (int, optional)
    
  - **small-local** (str, optional)
    
  - **store-bedgraph** (bool, optional)
    
  - **to-large** (bool, optional)
    
  - **verbose** (int, optional)
    
    - possible values:
    
      - 0
      - 1
      - 2
      - 3

**Required tools:** cat4m, macs2, pigz

**CPU Cores:** 4

.. index:: merge_bam_by_replicate

merge_bam_by_replicate
~~~~~~~~~~~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      merge_bam_by_replicate [style=filled, fillcolor="#fce94f"];
      in_0 [label="alignments"];
      in_0 -> merge_bam_by_replicate;
      out_1 [label="alignments"];
      merge_bam_by_replicate -> out_1;
      out_2 [label="indices"];
      merge_bam_by_replicate -> out_2;
   }    

**Options:**
  - **replicate_groups** (dict, required)
    

**Required tools:** bamtools, cat4m, samtools

**CPU Cores:** 1

.. index:: merge_gencode_novel_workaround

merge_gencode_novel_workaround
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      merge_gencode_novel_workaround [style=filled, fillcolor="#fce94f"];
      in_0 [label="features"];
      in_0 -> merge_gencode_novel_workaround;
      out_1 [label="features"];
      merge_gencode_novel_workaround -> out_1;
      out_2 [label="log_stderr"];
      merge_gencode_novel_workaround -> out_2;
   }    

**Options:**
  - **reference** (str, required)
    

**Required tools:** cat4m, sort

**CPU Cores:** 1

.. index:: normalize_bigwig

normalize_bigwig
~~~~~~~~~~~~~~~~



Normalize_wig from the RSeQC package normalizes wig files based on wigsum.

From the RSeqQC package documentation (ver 3.2.9):
Therefore, only normalized to "total read count" is problematic if read length is different between samples.
Here we normalize every bigwig file into the same wigsum. wigsum is the summary of signal value across the genome. for example, wigsum = 100,000,000 equals to
the coverage achieved by 1 million 100nt long reads or 2 million 50nt long reads.

Options:
--version 	show program version number and exit
-h, --help 	show this help message and exit
-i BIGWIG_FILE, --bwfile=BIGWIG_FILE
Input BigWig file. [required]
-o OUTPUT_WIG, --output=OUTPUT_WIG
Output wig file. [required]
-s CHROMSIZE, --chromSize=CHROMSIZE
Chromosome size file. Tab or space separated text file with 2 columns: first column is chromosome name, second column is size of the chromosome. [required]
-t TOTAL_WIGSUM, --wigsum=TOTAL_WIGSUM
Specified wigsum. 100000000 equals to coverage of 1 million 100nt reads. default=100000000 [optional]
-r REFGENE_BED, --refgene=REFGENE_BED
Reference gene model in bed format. [optional]
-c CHUNK_SIZE, --chunk=CHUNK_SIZE
Chromosome chunk size. Each chomosome will be cut into samll chunks of this size. Decrease chunk size will save more RAM. default=100000 (bp) [optional]

All options are available through this interface.
The chromsizes file can be obtain using UCSC tool fetchChromSizes.
-i and -o do not apply as they are set by the pipeline automatically

**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      normalize_bigwig [style=filled, fillcolor="#fce94f"];
      in_0 [label="tracks"];
      in_0 -> normalize_bigwig;
      out_1 [label="tracks"];
      normalize_bigwig -> out_1;
   }    

**Options:**
  - **c** (int, optional)
    
  - **r** (str, optional)
    
  - **s** (str, required)
    
  - **t** (int, optional)
    

**Required tools:** normalize_bigwig, wigToBigWig

**CPU Cores:** 1

.. index:: post_cufflinks_merge

post_cufflinks_merge
~~~~~~~~~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      post_cufflinks_merge [style=filled, fillcolor="#fce94f"];
      in_0 [label="features"];
      in_0 -> post_cufflinks_merge;
      out_1 [label="features"];
      post_cufflinks_merge -> out_1;
      out_2 [label="log_stderr"];
      post_cufflinks_merge -> out_2;
   }    

**Options:**
  - **class_list** (str, optional)
    
  - **filter_by_class** (bool, required)
    
  - **filter_by_class_and_gene_name** (bool, required)
    
  - **remove_by_gene_name** (bool, required)
    
  - **remove_gencode** (bool, required)
    
  - **remove_unstranded** (bool, required)
    
  - **string** (str, optional)
    

**Required tools:** cat4m, post_cufflinks_merge

**CPU Cores:** 2

.. index:: post_sawdust

post_sawdust
~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      post_sawdust [style=filled, fillcolor="#fce94f"];
      in_0 [label="alignments"];
      in_0 -> post_sawdust;
      out_1 [label="alignments"];
      post_sawdust -> out_1;
      out_2 [label="log_stderr"];
      post_sawdust -> out_2;
   }    

**Options:**
  - **library_type** (str, required)
    
    - possible values:
    
      - fr-firststrand
      - fr-secondstrand
      - fr-unstranded
  - **seq_type** (str, required)
    
    - possible values:
    
      - DNA
      - RNA

**Required tools:** cat4m, post_sawdust, samtools

**CPU Cores:** 6

.. index:: random_sample_fastq

random_sample_fastq
~~~~~~~~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      random_sample_fastq [style=filled, fillcolor="#fce94f"];
      in_0 [label="reads"];
      in_0 -> random_sample_fastq;
      out_1 [label="reads"];
      random_sample_fastq -> out_1;
   }    

**Options:**
  - **sample_size** (int, required)
    

**Required tools:** pigz, random_sample_fastq

**CPU Cores:** 3

.. index:: remove_duplicate_reads

remove_duplicate_reads
~~~~~~~~~~~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      remove_duplicate_reads [style=filled, fillcolor="#fce94f"];
      in_0 [label="alignments"];
      in_0 -> remove_duplicate_reads;
      out_1 [label="alignments"];
      remove_duplicate_reads -> out_1;
      out_2 [label="metrics"];
      remove_duplicate_reads -> out_2;
   }    

**Options:**

**Required tools:** MarkDuplicates, cat4m

**CPU Cores:** 12

.. index:: rename_gtf_segemehl

rename_gtf_segemehl
~~~~~~~~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      rename_gtf_segemehl [style=filled, fillcolor="#fce94f"];
      in_0 [label="features"];
      in_0 -> rename_gtf_segemehl;
      out_1 [label="features_segemehl"];
      rename_gtf_segemehl -> out_1;
   }    

**Options:**

**Required tools:** cat4m

**CPU Cores:** 1

.. index:: rename_gtf_tophat

rename_gtf_tophat
~~~~~~~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      rename_gtf_tophat [style=filled, fillcolor="#fce94f"];
      in_0 [label="features"];
      in_0 -> rename_gtf_tophat;
      out_1 [label="features_tophat"];
      rename_gtf_tophat -> out_1;
   }    

**Options:**

**Required tools:** cat4m

**CPU Cores:** 1

.. index:: s2c

s2c
~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      s2c [style=filled, fillcolor="#fce94f"];
      in_0 [label="alignments"];
      in_0 -> s2c;
      out_1 [label="alignments"];
      s2c -> out_1;
      out_2 [label="log"];
      s2c -> out_2;
   }    

**Options:**

**Required tools:** cat4m, pigz, s2c, samtools

**CPU Cores:** 6

.. index:: sam_to_bam

sam_to_bam
~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      sam_to_bam [style=filled, fillcolor="#fce94f"];
      in_0 [label="alignments"];
      in_0 -> sam_to_bam;
      out_1 [label="alignments"];
      sam_to_bam -> out_1;
      out_2 [label="indices"];
      sam_to_bam -> out_2;
   }    

**Options:**
  - **genome** (str, required)
    
  - **sort_by_name** (bool, required)
    

**Required tools:** cat4m, pigz, samtools

**CPU Cores:** 4

.. index:: segemehl

segemehl
~~~~~~~~



segemehl is a software to map short sequencer reads to reference genomes.
Unlike other methods, segemehl is able to detect not only mismatches but
also insertions and deletions. Furthermore, segemehl is not limited to a
specific read length and is able to mapprimer- or polyadenylation
contaminated reads correctly.

This step creates at first two FIFOs. The first through which segemehl gets
its genome data and the second to which it writes unmapped reads::

mkfifo genome_fifo unmapped_fifo
cat4m <genome-fasta> -o genome_fifo

The executed segemehl command is this::

segemehl -d genome_fifo -i <genome-index-file> -q <read1-fastq> [-p <read2-fastq>] -u unmapped_fifo -H 1 -t 11 -s -S -D 0 -o /dev/stdout |  pigz --blocksize 4096 --processes 2 -c

The unmapped reads are saved via these commands::

cat4m unmapped_fifo | pigz --blocksize 4096 --processes 2 -c > <unmapped-fastq>


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      segemehl [style=filled, fillcolor="#fce94f"];
      in_0 [label="first_read"];
      in_0 -> segemehl;
      in_1 [label="second_read"];
      in_1 -> segemehl;
      out_2 [label="alignments"];
      segemehl -> out_2;
      out_3 [label="log"];
      segemehl -> out_3;
      out_4 [label="unmapped"];
      segemehl -> out_4;
   }    

**Options:**
  - **genome** (str, required)
    
  - **index** (str, required)
    

**Required tools:** cat4m, pigz, segemehl

**CPU Cores:** 12

.. index:: testrealign

testrealign
~~~~~~~~~~~


**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      testrealign [style=filled, fillcolor="#fce94f"];
      in_0 [label="alignments"];
      in_0 -> testrealign;
      out_1 [label="alignments"];
      testrealign -> out_1;
      out_2 [label="log_stderr"];
      testrealign -> out_2;
      out_3 [label="splicesites"];
      testrealign -> out_3;
      out_4 [label="transrealigned"];
      testrealign -> out_4;
   }    

**Options:**
  - **genome** (str, required)
    
  - **maxdist** (int, required)
    

**Required tools:** cat4m, pigz, samtools, testrealign

**CPU Cores:** 12

.. index:: tophat2

tophat2
~~~~~~~



TopHat is a fast splice junction mapper for RNA-Seq reads.
It aligns RNA-Seq reads to mammalian-sized
genomes using the ultra high-throughput short read aligner Bowtie
, and then analyzes the mapping results to identify splice junctions between exons.

http://tophat.cbcb.umd.edu/

typical command line::

tophat [options]* <index_base> <reads1_1[,...,readsN_1]> [reads1_2,...readsN_2]



**Connections:**

.. graphviz::

   digraph foo {
      rankdir = LR;
      splines = true;
      graph [fontname = Helvetica, fontsize = 12, size = "14, 11", nodesep = 0.2, ranksep = 0.3];
      node [fontname = Helvetica, fontsize = 12, shape = rect];
      edge [fontname = Helvetica, fontsize = 12];
      tophat2 [style=filled, fillcolor="#fce94f"];
      in_0 [label="first_read"];
      in_0 -> tophat2;
      in_1 [label="second_read"];
      in_1 -> tophat2;
      out_2 [label="align_summary"];
      tophat2 -> out_2;
      out_3 [label="alignments"];
      tophat2 -> out_3;
      out_4 [label="deletions"];
      tophat2 -> out_4;
      out_5 [label="insertions"];
      tophat2 -> out_5;
      out_6 [label="junctions"];
      tophat2 -> out_6;
      out_7 [label="log_stderr"];
      tophat2 -> out_7;
      out_8 [label="misc_logs"];
      tophat2 -> out_8;
      out_9 [label="prep_reads"];
      tophat2 -> out_9;
      out_10 [label="unmapped"];
      tophat2 -> out_10;
   }    

**Options:**
  - **index** (str, required)
    
  - **library_type** (str, required)
    
    - possible values:
    
      - fr-firststrand
      - fr-secondstrand
      - fr-unstranded
  - **swap_reads** (bool, required)
    

**Required tools:** bowtie2, cat4m, pigz, tophat2

**CPU Cores:** 6

