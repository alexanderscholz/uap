#!/usr/bin/env python
# encoding: utf-8

import sys
import argparse
#import pipeline
import string
import yaml

'''
By default, this script displays information about all tasks of the pipeline
configured in 'config.yaml'. But the displayed information can be narrowed 
down via command line options.

'''

parser = argparse.ArgumentParser(
    description="This script controls the 'seq-pipeline'.",
    formatter_class=argparse.RawTextHelpFormatter)

subparsers = parser.add_subparsers(help="sub-command help")

'''
The argument parser for 'fix-problems.py' is created here."
'''

fix_problems_parser = subparsers.add_parser(
    "fix-problems",
    help="help",
    description="This script displays by default information about all tasks " +
                "of the pipeline as configured in 'config.yaml'. But the " +
                "displayed information can be narrowed down via command " +
                "line options.")

fix_problems_parser.add_argument("--cluster",
                    dest="cluster",
                    type=str,
                    default="auto",
                    help="Specify the cluster type (sge, slurm), defaults to auto.")

fix_problems_parser.add_argument("--details",
                    dest="details",
                    action="store_true",
                    default=False,
                    help="Displays detailed information about problems that " +
                    "occured during the execution of the pipeline.")

fix_problems_parser.add_argument("--srsly",
                    dest="srsly",
                    action="store_true",
                    default=False,
                    help="Fixes the problems that the pipeline has encountered.")

fix_problems_parser.add_argument("--even-if-dirty",
                    dest="even_if_dirty",
                    action="store_true",
                    default=False,
                    help="Must be set if the local git repository " +
                    "contains uncommited changes. Otherwise the pipeline " +
                    "will not start.")



'''
The argument parser for 'render.py' is created here."
'''

render_parser = subparsers.add_parser(
    "render",
    help="help",
    description="This script displays by default information about all tasks " +
                "of the pipeline as configured in 'config.yaml'. But the " +
                "displayed information can be narrowed down via command " +
                "line options.")

render_parser.add_argument("--even-if-dirty",
                    dest="even_if_dirty",
                    action="store_true",
                    default=False,
                    help="Must be set if the local git repository " +
                    "contains uncommited changes. Otherwise the pipeline " +
                    "will not start.")

render_parser.add_argument("--all",
                    dest="all",
                    action="store_true",
                    default=False,
                    help="Renders all ")

render_parser.add_argument("-t","--task",
                    dest="task",
                    nargs='*',
                    default=list(),
                    type=str,
                    help="Displays only the named task IDs" +
                    "Can take multiple task ID(s) as input. A task ID " +
                    "looks like ths 'step_name/run_id'. A list of all " +
                    "task IDs is returned by running './status.py'.")

'''
The argument parser for 'status.py' is created here."
'''

run_locally_parser = subparsers.add_parser(
    "run-locally",
    help="help",
    description="This script starts the 'rnaseq-pipeline' on the local machine. "
                "It can be used to start:\n"
                " * all tasks of the pipeline as configured in 'config.yaml'\n"
                " * all tasks defined by a specific step in 'config.yaml'\n"
                " * one or more steps\n"
                "To start the complete pipeline as configured in 'config.yaml' "
                "execute:\n"
                "$ ./run-locally.py\n"
                "To start a specific step execute:\n"
                "$ ./run-locally.py <step_name>\n"
                "To start a specific task execute:\n"
                "$ ./run-locally.py <step_name/run_id>\n"
                "The step_name is the name of an entry in the 'steps:' section "
                "as defined in 'config.yaml'. A specific task is defined via "
                "its task ID 'step_name/run_id'. A list of all task IDs is " 
                "returned by running './status.py'.")

run_locally_parser.add_argument("--even-if-dirty",
                    dest="even_if_dirty",
                    action="store_true",
                    default=False,
                    help="Must be set if the local git repository "
                    "contains uncommited changes. Otherwise the pipeline "
                    "will not start.")

run_locally_parser.add_argument("step_task",
                    nargs='*',
                    default=list(),
                    type=str,
                    help="Can take multiple step names as input. A step name "
                    "is the name of any entry in the 'steps:' section "
                    "as defined in 'config.yaml'. A list of all task IDs "
                    "is returned by running './status.py'.")


'''
The argument parser for 'status.py' is created here."
'''

status_parser = subparsers.add_parser(
    "status",
    help="help",
    description="This script displays by default information about all tasks "
                "of the pipeline as configured in 'config.yaml'. But the "
                "displayed information can be narrowed down via command "
                "line options.\n"
                "IMPORTANT: Hints given by this script are just valid if YOU "
                "submitted the jobs to the cluster.")



status_parser.add_argument("--cluster",
                    dest="cluster",
                    type=str,
                    default="auto",
                    help="Specify the cluster type (sge, slurm), defaults to auto.")

status_parser.add_argument("--summarize",
                    dest="summarize",
                    action="store_true",
                    default=False,
                    help="Displays summarized information of the pipeline")

status_parser.add_argument("--graph",
                    dest="graph",
                    action="store_true",
                    default=False,
                    help="Displays the dependency graph of the pipeline")

status_parser.add_argument("--even-if-dirty",
                    dest="even_if_dirty",
                    action="store_true",
                    default=False,
                    help="Must be set if the local git repository " +
                    "contains uncommited changes. Otherwise the pipeline " +
                    "will not start.")

status_parser.add_argument("--sources",
                    dest="sources",
                    action="store_true",
                    default=False,
                    help="Displays only information about the source runs.")

status_parser.add_argument("-t","--task",
                    dest="task",
                    nargs='*',
                    default=list(),
                    type=str,
                    help="Displays only the named task IDs. " +
                    "Can take multiple task ID(s) as input. A task ID " +
                    "looks like ths 'step_name/run_id'. A list of all " +
                    "task IDs is returned by running './status.py'.")

'''
The argument parser for 'submit-to-cluster.py' is created here."
'''

submit_to_cluster_parser = subparsers.add_parser(
    "submit-to-cluster",
    help="help",
    description='This script submits all tasks configured in config.yaml to a ' +
                'Sun GridEngine or SLURM cluster. The list of tasks can be ' +
                'narrowed down by specifying a step name (in which case all ' +
                'runs of this steps will be considered) or individual tasks ' +
                '(step_name/run_id).')

submit_to_cluster_parser.add_argument("--even-if-dirty",
                    dest="even_if_dirty",
                    action="store_true",
                    default=False,
                    help="Must be set if the local git repository " +
                    "contains uncommitted changes. Otherwise the pipeline " +
                    "will not start.")

submit_to_cluster_parser.add_argument("--cluster",
                    dest="cluster",
                    type=str,
                    default="auto",
                    help="Specify the cluster type (sge, slurm), defaults to auto.")

submit_to_cluster_parser.add_argument("step_task",
                    nargs='*',
                    default=list(),
                    type=str,
                    help="Can take multiple step names as input. A step name " +
                    "is the name of any entry in the 'steps:' section " +
                    "as defined in 'config.yaml'. A list of all task IDs " +
                    "is returned by running './status.py'.")

'''
The argument parser for 'volatilize.py' is created here."
'''

volatilize_parser = subparsers.add_parser(
    "volatilize",
    help="help",
    description="This script does something, of course.")

volatilize_parser.add_argument("--details",
                    dest="details",
                    action="store_true",
                    default=False,
                    help="Displays detailed information about ")

volatilize_parser.add_argument("--srsly",
                    dest="srsly",
                    action="store_true",
                    default=False,
                    help="")

volatilize_parser.add_argument("--even-if-dirty",
                    dest="even_if_dirty",
                    action="store_true",
                    default=False,
                    help="Must be set if the local git repository " +
                    "contains uncommited changes. Otherwise the pipeline " +
                    "will not start.")


args = parser.parse_args()


def main():
    p = pipeline.Pipeline(arguments=args)
    group_by_status = True

    if args.sources:
        # print all sources (i. e. instances of AbstractSourceStep)
        p.print_source_runs()

    elif len( args.task ) >= 1:
        # print run infos of one or more specific tasks
        for task_id in args.task:
            parts = task_id.split('/')
            if len(parts) != 2:
                raise StandardError("Invalid task ID %s." % task_id)
            step_name = parts[0]
            run_id = parts[1]
            report = p.steps[step_name].get_run_info()[run_id].as_dict()
            report['state'] = p.steps[step_name].get_run_state(run_id)
            print(yaml.dump(report, default_flow_style = False))
        
    elif args.graph:
        step_order = p.topological_step_order
        indents = [0 for _ in step_order]
        for index, line in enumerate(step_order):
            step_name = step_order[index]
            child_count = len(p.steps[step_name].children_step_names)
            indent = child_count * 2
            for _ in range(index + 1, len(step_order)):
                indents[_] += indent
            lines = list()
            for index, step_name in enumerate(step_order):
                lines.append(list(' ' * indents[index]))

        # draw horizontal line parts
        for index, step_name in enumerate(step_order):
            child_order = [_ for _ in step_order if _ in p.steps[step_name].children_step_names]
            for child_index, child in enumerate(child_order):
                x0 = indents[index] + 1 + child_index * 2
                y = step_order.index(child)
                x1 = indents[y]
                for x in range(x0, x1):
                    lines[y][x] = "─"
                lines[y][x0 - 1] = "└"

        # draw vertical line parts
        for index, step_name in enumerate(step_order):
            child_order = [_ for _ in step_order if _ in p.steps[step_name].children_step_names]
            for child_index, child in enumerate(child_order):
                x = indents[index] + child_index * 2
                y0 = index + 1
                y1 = step_order.index(child)
                for y in range(y0, y1):
                    lines[y][x] = "│"

        for index, _ in enumerate(lines):
            original_step_name_label = ''
            step = p.steps[step_order[index]]
            if step.get_step_name() != step.get_step_type():
                original_step_name_label = ' (%s)' % step.get_step_type()

            line = "%s%s%s [%s]" % (''.join(_).replace("─└", "─┴"), step.get_step_name(), original_step_name_label, step.get_run_info_str())
            print(line)
    else:
        # print all tasks
        '''
        prints a summary of all tasks, indicating whether each taks is
        - ``[r]eady``
        - ``[w]aiting``
        - ``[q]ueued``
        - ``[e]xecuting``
        - ``[f]inished``
        '''
        tasks_for_status = {}
        for task in p.all_tasks_topologically_sorted:
            state = task.get_task_state()
            if not state in tasks_for_status:
                    tasks_for_status[state] = list()
            tasks_for_status[state].append(task)
            if not group_by_status:
                print("[%s] %s" % (task.get_task_state()[0].lower(), task))
        if group_by_status:
            for status in p.states.order:
                if not status in tasks_for_status:
                    continue
                heading = "%s tasks" % string.capwords(status)
                print(heading)
                print('-' * len(heading))
                if args.summarize:
                    step_count = dict()
                    step_order = list()
                    for task in tasks_for_status[status]:
                        if not str(task.step) in step_count:
                            step_count[str(task.step)] = 0
                            step_order.append(str(task.step))
                        step_count[str(task.step)] += 1
                    for step_name in step_order:
                        print("[%s]%4d %s" % (status.lower()[0], step_count[step_name], step_name))
                else:
                    for task in tasks_for_status[status]:
                        print("[%s] %s" % (task.get_task_state()[0].lower(), task))
                print('')
        print("tasks: %d total, %s" % (len(p.all_tasks_topologically_sorted), ', '.join(["%d %s" % (len(tasks_for_status[_]), _.lower()) for _ in p.states.order if _ in tasks_for_status])))
            
    # now check ping files and print some warnings and instructions if something's fishy
    p.check_ping_files()
    
    # Now check whether we can volatilize files, but don't do it.
    p.check_volatile_files()
        
if __name__ == '__main__':
    main()
